<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Time-Locked Camera</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    video, img { width: 100%; max-width: 520px; border-radius: 12px; background: #eee; }
    button, select {
      padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff;
      margin: 6px 6px 6px 0; font-size: 16px;
    }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .muted { color: #666; }
    .card { border: 1px solid #e5e5e5; border-radius: 12px; padding: 12px; margin-top: 12px; max-width: 540px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; border: 1px solid #ddd; }
    .danger { border-color: #f2b8b5; background: #fff5f5; }
    .ok { border-color: #b8e6c8; background: #f5fff8; }
    .warn { border-color: #f5d37a; background: #fffaf0; }
    .mutedpill { color:#666; }
    .label { color:#666; font-size: 14px; }
    .preset-btn { padding: 8px 12px; font-size: 14px; }
    .preset-active { border-color: #999; }

    /* purely cosmetic extra blur on the masked preview (the mosaic is also baked into the image) */
    .maskedPreview { filter: blur(2px); }
  </style>
</head>
<body>
  <h2>Time-Locked Camera (Prototype) v0.3 </h2>
  <p class="muted">
    Lock/unlock is based on internet time. If time cannot be verified (offline), the countdown pauses and stays locked.
    During lock, a masked (mosaic) preview is shown so you can confirm framing without reading details.
  </p>

  <div class="card">
    <div class="row">
      <span class="label">Delay presets:</span>
      <button class="preset-btn" data-preset-min="1">1 min</button>
      <button class="preset-btn" data-preset-min="10">10 min</button>
      <button class="preset-btn" data-preset-min="30">30 min</button>
      <button class="preset-btn" data-preset-min="60">1 hour</button>
    </div>

    <div class="row">
      <span class="label">Custom delay:</span>

      <select id="hours" aria-label="Hours"></select>
      <span class="label">hour(s)</span>

      <select id="mins" aria-label="Minutes"></select>
      <span class="label">min(s)</span>
    </div>

    <div class="row">
      <button id="start">Start Camera</button>
      <button id="switch" disabled>Switch Camera (Back)</button>
      <button id="snap" disabled>Take Photo</button>
      <button id="clear">Clear Stored Photo</button>
    </div>

    <div class="row" style="margin-top:8px;">
      <span id="lockState" class="pill mutedpill">No photo stored</span>
      <span id="countdown" class="pill mutedpill mono">--:--:--</span>
      <span id="timeState" class="pill mutedpill">Time: checking…</span>
    </div>

    <p id="status" class="muted" style="margin-top:10px;"></p>

    <video id="video" playsinline autoplay muted style="display:none; margin-top:10px;"></video>
    <canvas id="canvas" style="display:none;"></canvas>

    <!-- Will show masked preview during lock, and clear photo after unlock -->
    <img id="photo" alt="Photo Preview" style="display:none; margin-top: 10px;" />
  </div>

<script>
/**
 * IndexedDB storage:
 * - photoDataUrl: string (jpeg data URL)               [full-resolution]
 * - maskedPhotoDataUrl: string (jpeg data URL)         [mosaic preview]
 * - unlockAtServer: number (epoch ms, based on internet time)
 * - createdAtServer: number (epoch ms)
 *
 * Time sync:
 * - offsetMs: serverNowMs - Date.now()
 * - lastSyncLocalMs: Date.now() when we last successfully synced
 *
 * Fail-safe: if time sync is stale/offline, countdown pauses and unlock cannot occur.
 * During lock (including paused), show maskedPhotoDataUrl if available.
 */

const dbName = "time_lock_db_v6";
const storeName = "kv";

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(dbName, 1);
    req.onupgradeneeded = () => req.result.createObjectStore(storeName);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbSet(key, val) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).put(val, key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
async function idbGet(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const req = tx.objectStore(storeName).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbDel(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).delete(key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

// UI elements
const $ = (id) => document.getElementById(id);
const video = $("video");
const canvas = $("canvas");
const img = $("photo");
const statusEl = $("status");
const lockStateEl = $("lockState");
const countdownEl = $("countdown");
const timeStateEl = $("timeState");
const snapBtn = $("snap");
const startBtn = $("start");
const switchBtn = $("switch");
const hoursSel = $("hours");
const minsSel = $("mins");

// Preset buttons
const presetButtons = Array.from(document.querySelectorAll("button[data-preset-min]"));

let stream = null;

// Camera selection state
let desiredFacing = "environment";
let deviceMap = { user: null, environment: null };

// Time sync state
let offsetMs = null;
let lastSyncLocalMs = 0;
let lastServerNowEstimateMs = 0;
let frozenRemainingMs = null;
let lastTimeSource = "";

// Tunables
const TIME_URLS = [
  "https://timeapi.world/api/ip",
  "https://worldtimeapi.org/api/ip",
  "https://worldtimeapi.org/api/timezone/Etc/UTC"
];
const SYNC_INTERVAL_MS = 20000;
const MAX_SYNC_AGE_MS = 60000;
const FETCH_TIMEOUT_MS = 4000;

// Mask tuning (bigger = stronger mosaic)
const MOSAIC_BLOCK_PX = 26;  // try 20–40 depending on how “unreadable” you want it

let renderTimer = null;
let syncTimer = null;

function setStatus(msg) { statusEl.textContent = msg; }

function setLockPill(text, kind) {
  lockStateEl.textContent = text;
  lockStateEl.className = "pill " + (kind === "danger" ? "danger" : kind === "ok" ? "ok" : "mutedpill");
}
function setTimePill(text, kind) {
  timeStateEl.textContent = text;
  timeStateEl.className = "pill " + (kind === "warn" ? "warn" : "mutedpill");
}

function formatDuration(ms) {
  if (ms < 0) ms = 0;
  const totalSec = Math.floor(ms / 1000);
  const hh = String(Math.floor(totalSec / 3600)).padStart(2, "0");
  const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, "0");
  const ss = String(totalSec % 60).padStart(2, "0");
  return `${hh}:${mm}:${ss}`;
}

function populateTimeDropdowns() {
  for (let h = 0; h <= 23; h++) {
    const opt = document.createElement("option");
    opt.value = String(h);
    opt.textContent = String(h);
    hoursSel.appendChild(opt);
  }
  for (let m = 0; m <= 59; m++) {
    const opt = document.createElement("option");
    opt.value = String(m);
    opt.textContent = String(m).padStart(2, "0");
    minsSel.appendChild(opt);
  }
}

function setDelayFromMinutes(totalMinutes) {
  const h = Math.floor(totalMinutes / 60);
  const m = totalMinutes % 60;
  hoursSel.value = String(h);
  minsSel.value = String(m);
  updatePresetHighlight();
}

function updatePresetHighlight() {
  const totalMinutes = Number(hoursSel.value) * 60 + Number(minsSel.value);
  presetButtons.forEach(btn => {
    const presetMin = Number(btn.getAttribute("data-preset-min"));
    btn.classList.toggle("preset-active", presetMin === totalMinutes);
  });
}

function buildDelayMs() {
  const h = Number(hoursSel.value);
  const m = Number(minsSel.value);
  return (h * 60 + m) * 60 * 1000;
}

async function getStored() {
  const unlockAtServer = await idbGet("unlockAtServer");
  const photoDataUrl = await idbGet("photoDataUrl");
  const maskedPhotoDataUrl = await idbGet("maskedPhotoDataUrl");
  const createdAtServer = await idbGet("createdAtServer");
  return { unlockAtServer, photoDataUrl, maskedPhotoDataUrl, createdAtServer };
}

// ---- Time sync ----

function isTimeFresh() {
  return (offsetMs !== null) && (Date.now() - lastSyncLocalMs <= MAX_SYNC_AGE_MS);
}

function estimatedServerNowMs() {
  if (offsetMs === null) return null;
  return Date.now() + offsetMs;
}

async function fetchWithTimeout(url, timeoutMs) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { signal: controller.signal, cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  } finally {
    clearTimeout(timer);
  }
}

async function syncTime() {
  for (const url of TIME_URLS) {
    const t0 = Date.now();
    try {
      const data = await fetchWithTimeout(url, FETCH_TIMEOUT_MS);
      const t1 = Date.now();

      let serverNowMs = null;

      if (data && typeof data.utc_datetime === "string") {
        const parsed = Date.parse(data.utc_datetime);
        if (!Number.isNaN(parsed)) serverNowMs = parsed;
      }
      if (serverNowMs === null && data && typeof data.datetime === "string") {
        const parsed = Date.parse(data.datetime);
        if (!Number.isNaN(parsed)) serverNowMs = parsed;
      }
      if (serverNowMs === null && data && typeof data.unixtime === "number") {
        serverNowMs = data.unixtime * 1000;
      }
      if (serverNowMs === null && data && typeof data.epoch === "number") {
        serverNowMs = data.epoch * 1000;
      }
      if (serverNowMs === null) throw new Error("No usable time fields");

      const localMidMs = t0 + Math.round((t1 - t0) / 2);
      offsetMs = serverNowMs - localMidMs;
      lastSyncLocalMs = Date.now();
      lastTimeSource = url;

      frozenRemainingMs = null;
      return true;
    } catch (e) {
      // try next provider
    }
  }
  return false;
}

function updateTimePill() {
  if (isTimeFresh()) {
    const age = Date.now() - lastSyncLocalMs;
    const host = lastTimeSource ? new URL(lastTimeSource).host : "time service";
    setTimePill(`Time: verified via ${host} (${Math.round(age/1000)}s ago)`, "muted");
  } else {
    setTimePill("Time: not verified (offline) — paused", "warn");
  }
}

// ---- Mask generation (mosaic) ----

function loadImageFromDataUrl(dataUrl) {
  return new Promise((resolve, reject) => {
    const im = new Image();
    im.onload = () => resolve(im);
    im.onerror = reject;
    im.src = dataUrl;
  });
}

async function createMosaicPreviewDataUrl(fullDataUrl) {
  const im = await loadImageFromDataUrl(fullDataUrl);

  const w = im.naturalWidth || im.width;
  const h = im.naturalHeight || im.height;

  // Downscale to create pixel blocks, then upscale without smoothing.
  const scaleW = Math.max(1, Math.floor(w / MOSAIC_BLOCK_PX));
  const scaleH = Math.max(1, Math.floor(h / MOSAIC_BLOCK_PX));

  const small = document.createElement("canvas");
  small.width = scaleW;
  small.height = scaleH;

  const smallCtx = small.getContext("2d");
  smallCtx.imageSmoothingEnabled = true;
  // Draw into tiny canvas (averaging)
  smallCtx.drawImage(im, 0, 0, scaleW, scaleH);

  const out = document.createElement("canvas");
  out.width = w;
  out.height = h;

  const outCtx = out.getContext("2d");
  // Optional slight blur (supported in modern Safari; if not, it will just ignore)
  try { outCtx.filter = "blur(1.2px)"; } catch (_) {}
  outCtx.imageSmoothingEnabled = false;
  // Upscale (pixelated)
  outCtx.drawImage(small, 0, 0, scaleW, scaleH, 0, 0, w, h);

  // Reset filter to avoid affecting later draws
  try { outCtx.filter = "none"; } catch (_) {}

  return out.toDataURL("image/jpeg", 0.80);
}

// ---- Camera helpers ----

function stopCameraIfRunning() {
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  video.style.display = "none";
  snapBtn.disabled = true;
  switchBtn.disabled = true;
}

async function refreshDeviceMap() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d => d.kind === "videoinput");
    let front = null, back = null;

    for (const cam of cams) {
      const label = (cam.label || "").toLowerCase();
      if (!front && (label.includes("front") || label.includes("user") || label.includes("facetime"))) front = cam.deviceId;
      if (!back && (label.includes("back") || label.includes("rear") || label.includes("environment"))) back = cam.deviceId;
    }
    if ((!front || !back) && cams.length >= 2) {
      back = back || cams[0].deviceId;
      front = front || cams[cams.length - 1].deviceId;
    }
    deviceMap.user = front;
    deviceMap.environment = back;
  } catch (_) {}
}

async function startCameraWithFacing(facing) {
  desiredFacing = facing;
  stopCameraIfRunning();

  const tryGetUserMedia = async (constraints) => {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    video.style.display = "block";
    snapBtn.disabled = false;
    switchBtn.disabled = false;
  };

  const deviceId = deviceMap[facing];

  try {
    if (deviceId) {
      await tryGetUserMedia({ video: { deviceId: { exact: deviceId } }, audio: false });
    } else {
      await tryGetUserMedia({ video: { facingMode: { ideal: facing } }, audio: false });
    }

    await refreshDeviceMap();
    switchBtn.textContent = `Switch Camera (${desiredFacing === "environment" ? "Back" : "Front"})`;
    setStatus(`Camera started (${desiredFacing === "environment" ? "Back" : "Front"}). Tap 'Take Photo'.`);
  } catch (e1) {
    try {
      await tryGetUserMedia({ video: { facingMode: { exact: facing } }, audio: false });
      await refreshDeviceMap();
      switchBtn.textContent = `Switch Camera (${desiredFacing === "environment" ? "Back" : "Front"})`;
      setStatus(`Camera started (${desiredFacing === "environment" ? "Back" : "Front"}). Tap 'Take Photo'.`);
    } catch (e2) {
      console.error(e1, e2);
      setStatus("Camera unavailable or permission denied. Ensure HTTPS + Safari and Camera permission is allowed.");
      stopCameraIfRunning();
    }
  }
}

async function startCamera() {
  // User-gesture sync (more reliable on iOS PWA than background-only sync)
  await syncTime();
  updateTimePill();

  if (!isTimeFresh()) {
    setStatus("Internet time is not verified. Please reconnect (Wi-Fi/cellular) and try again. Countdown stays paused until time sync succeeds.");
    return;
  }
  await startCameraWithFacing(desiredFacing);
}

async function switchCamera() {
  const next = (desiredFacing === "environment") ? "user" : "environment";
  await startCameraWithFacing(next);
}

// ---- Main render loop ----

async function render() {
  const { unlockAtServer, photoDataUrl, maskedPhotoDataUrl, createdAtServer } = await getStored();

  updateTimePill();

  if (isTimeFresh()) {
    const est = estimatedServerNowMs();
    if (est !== null) lastServerNowEstimateMs = est;
  }

  // No stored photo
  if (!unlockAtServer || !photoDataUrl) {
    img.style.display = "none";
    img.classList.remove("maskedPreview");
    countdownEl.textContent = "--:--:--";
    setLockPill("No photo stored", "muted");
    setStatus(isTimeFresh()
      ? "Ready. Choose delay, start camera, take photo."
      : "Offline. This app requires internet time verification. Countdown (if any) will pause until verified."
    );
    return;
  }

  const fresh = isTimeFresh();

  // If offline/stale => paused; show masked preview and freeze countdown
  if (!fresh) {
    setLockPill("Locked (Paused)", "danger");

    // Always show masked preview during lock period (including paused)
    if (maskedPhotoDataUrl) {
      img.src = maskedPhotoDataUrl;
      img.style.display = "block";
      img.classList.add("maskedPreview");
    } else {
      img.style.display = "none";
      img.classList.remove("maskedPreview");
    }

    if (frozenRemainingMs === null) {
      const base = lastServerNowEstimateMs || (unlockAtServer - 1);
      frozenRemainingMs = unlockAtServer - base;
      if (frozenRemainingMs < 0) frozenRemainingMs = 0;
    }
    countdownEl.textContent = formatDuration(frozenRemainingMs);

    const unlockStr = new Date(unlockAtServer).toLocaleString();
    const createdStr = createdAtServer ? new Date(createdAtServer).toLocaleString() : "—";
    setStatus(`Photo is locked but time cannot be verified (offline). Countdown is paused. Created (server time): ${createdStr}. Unlocks at (server time): ${unlockStr}.`);
    return;
  }

  // Fresh time: countdown runs using estimated server time
  const serverNow = estimatedServerNowMs();
  const msLeft = unlockAtServer - serverNow;

  if (msLeft > 0) {
    setLockPill("Locked", "danger");
    frozenRemainingMs = null;
    countdownEl.textContent = formatDuration(msLeft);

    // Always show masked preview during lock period
    if (maskedPhotoDataUrl) {
      img.src = maskedPhotoDataUrl;
      img.style.display = "block";
      img.classList.add("maskedPreview");
    } else {
      img.style.display = "none";
      img.classList.remove("maskedPreview");
    }

    const unlockStr = new Date(unlockAtServer).toLocaleString();
    const createdStr = createdAtServer ? new Date(createdAtServer).toLocaleString() : "—";
    setStatus(`Photo is locked. Masked preview shown. Created (server time): ${createdStr}. Unlocks at (server time): ${unlockStr}.`);
  } else {
    // Unlocked (only allowed when time is verified)
    img.src = photoDataUrl;
    img.style.display = "block";
    img.classList.remove("maskedPreview");

    frozenRemainingMs = null;
    countdownEl.textContent = "00:00:00";
    setLockPill("Unlocked", "ok");

    const unlockStr = new Date(unlockAtServer).toLocaleString();
    setStatus(`Unlocked (time verified). Unlock time (server time): ${unlockStr}.`);
  }
}

// ---- Actions ----

async function takePhoto() {
  await syncTime();
  updateTimePill();

  if (!isTimeFresh()) {
    setStatus("Cannot take/lock a photo while offline. Reconnect to the internet so time can be verified.");
    return;
  }
  if (!stream) return;

  const delayMs = buildDelayMs();
  if (delayMs <= 0) {
    setStatus("Delay must be at least 1 minute (or set a non-zero value).");
    return;
  }

  // Capture frame
  const w = video.videoWidth || 1280;
  const h = video.videoHeight || 720;
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, w, h);

  const fullDataUrl = canvas.toDataURL("image/jpeg", 0.92);

  // Create masked preview (mosaic) so user can confirm photo without reading details
  let maskedDataUrl = null;
  try {
    maskedDataUrl = await createMosaicPreviewDataUrl(fullDataUrl);
  } catch (e) {
    // If masking fails for any reason, fall back to showing nothing during lock
    maskedDataUrl = null;
  }

  // Use server time estimate for lock start
  const serverNow = estimatedServerNowMs();
  const unlockAtServer = serverNow + delayMs;

  await idbSet("photoDataUrl", fullDataUrl);
  await idbSet("maskedPhotoDataUrl", maskedDataUrl);
  await idbSet("createdAtServer", serverNow);
  await idbSet("unlockAtServer", unlockAtServer);

  stopCameraIfRunning();
  await render();
}

async function clearAll() {
  await idbDel("photoDataUrl");
  await idbDel("maskedPhotoDataUrl");
  await idbDel("unlockAtServer");
  await idbDel("createdAtServer");
  stopCameraIfRunning();
  frozenRemainingMs = null;
  await render();
}

// ---- Wiring ----

presetButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    const presetMin = Number(btn.getAttribute("data-preset-min"));
    setDelayFromMinutes(presetMin);
    setStatus(`Delay set: ${presetMin} minute(s).`);
  });
});
hoursSel.addEventListener("change", updatePresetHighlight);
minsSel.addEventListener("change", updatePresetHighlight);

startBtn.addEventListener("click", startCamera);
switchBtn.addEventListener("click", switchCamera);
snapBtn.addEventListener("click", takePhoto);
$("clear").addEventListener("click", clearAll);

// ---- Boot ----

(async () => {
  populateTimeDropdowns();
  setDelayFromMinutes(60);

  setTimePill("Time: checking…", "warn");

  // Initial sync attempt (best-effort; real gating happens on Start/Take)
  await syncTime();
  updateTimePill();

  if (syncTimer) clearInterval(syncTimer);
  syncTimer = setInterval(async () => {
    await syncTime();
    updateTimePill();
  }, SYNC_INTERVAL_MS);

  if (renderTimer) clearInterval(renderTimer);
  renderTimer = setInterval(render, 1000);
  await render();

  document.addEventListener("visibilitychange", async () => {
    if (!document.hidden) {
      await syncTime();
      await render();
    }
  });

  switchBtn.disabled = true;
})();
</script>
</body>
</html>
