<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Time-Locked Camera</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    video, img { width: 100%; max-width: 520px; border-radius: 12px; background: #eee; }
    button, select {
      padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff;
      margin: 6px 6px 6px 0; font-size: 16px;
    }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .muted { color: #666; }
    .card { border: 1px solid #e5e5e5; border-radius: 12px; padding: 12px; margin-top: 12px; max-width: 540px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; border: 1px solid #ddd; }
    .danger { border-color: #f2b8b5; background: #fff5f5; }
    .ok { border-color: #b8e6c8; background: #f5fff8; }
    .warn { border-color: #f5d37a; background: #fffaf0; }
    .mutedpill { color:#666; }
    .label { color:#666; font-size: 14px; }
    .preset-btn { padding: 8px 12px; font-size: 14px; }
    .preset-active { border-color: #999; }
    .maskedPreview { filter: blur(2px); }
  </style>
</head>
<body>
  <h2>Time-Locked Camera (Prototype) v0.4</h2>
  <p class="muted">
    Timer starts immediately using local clock. Server time is checked every 1 minute in the background to validate/unlock.
    Temporary connection loss will not pause; timer pauses only after 3 consecutive failed checks.
    During lock, a masked (mosaic) preview is shown.
  </p>

  <div class="card">
    <div class="row">
      <span class="label">Delay presets:</span>
      <button class="preset-btn" data-preset-min="1">1 min</button>
      <button class="preset-btn" data-preset-min="10">10 min</button>
      <button class="preset-btn" data-preset-min="30">30 min</button>
      <button class="preset-btn" data-preset-min="60">1 hour</button>
    </div>

    <div class="row">
      <span class="label">Custom delay:</span>

      <select id="hours" aria-label="Hours"></select>
      <span class="label">hour(s)</span>

      <select id="mins" aria-label="Minutes"></select>
      <span class="label">min(s)</span>
    </div>

    <div class="row">
      <button id="start">Start Camera</button>
      <button id="switch" disabled>Switch Camera (Back)</button>
      <button id="snap" disabled>Take Photo</button>
      <button id="clear">Clear Stored Photo</button>
    </div>

    <div class="row" style="margin-top:8px;">
      <span id="lockState" class="pill mutedpill">No photo stored</span>
      <span id="countdown" class="pill mutedpill mono">--:--:--</span>
      <span id="timeState" class="pill mutedpill">Time: not checked yet</span>
    </div>

    <p id="status" class="muted" style="margin-top:10px;"></p>

    <video id="video" playsinline autoplay muted style="display:none; margin-top:10px;"></video>
    <canvas id="canvas" style="display:none;"></canvas>

    <img id="photo" alt="Photo Preview" style="display:none; margin-top: 10px;" />
  </div>

<script>
/**
 * IndexedDB storage:
 * - photoDataUrl: string (full jpeg data URL)
 * - maskedPhotoDataUrl: string (mosaic jpeg data URL)
 * - localUnlockAt: number (epoch ms, local clock-based)
 * - serverUnlockAt: number (epoch ms, server-validated target; set after successful sync)
 * - createdAtLocal: number (epoch ms)
 * - createdAtServer: number (epoch ms | null)
 *
 * Behavior:
 * - Countdown uses local clock by default (no delay on Start Camera).
 * - Every 1 minute, background tries to fetch server time and compute offset + serverUnlockAt.
 * - Unlock decision uses server time when available & healthy; otherwise local countdown continues.
 * - Only if 3 consecutive sync failures occur => pause (fail-safe), keeping masked preview.
 */

const dbName = "time_lock_db_v7";
const storeName = "kv";

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(dbName, 1);
    req.onupgradeneeded = () => req.result.createObjectStore(storeName);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbSet(key, val) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).put(val, key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
async function idbGet(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const req = tx.objectStore(storeName).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbDel(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).delete(key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

// UI
const $ = (id) => document.getElementById(id);
const video = $("video");
const canvas = $("canvas");
const img = $("photo");
const statusEl = $("status");
const lockStateEl = $("lockState");
const countdownEl = $("countdown");
const timeStateEl = $("timeState");
const snapBtn = $("snap");
const startBtn = $("start");
const switchBtn = $("switch");
const hoursSel = $("hours");
const minsSel = $("mins");

const presetButtons = Array.from(document.querySelectorAll("button[data-preset-min]"));

let stream = null;
let desiredFacing = "environment";
let deviceMap = { user: null, environment: null };

// Time sync state
let offsetMs = null;             // serverNow - localNow (computed on successful sync)
let lastSyncLocalMs = 0;
let lastTimeSource = "";
let consecutiveSyncFailures = 0;

let frozenRemainingMs = null;    // when paused after 3 failures
let pauseDueToNetwork = false;

// Tunables
const TIME_URLS = [
  "https://timeapi.world/api/ip",
  "https://worldtimeapi.org/api/ip",
  "https://worldtimeapi.org/api/timezone/Etc/UTC"
];
const FETCH_TIMEOUT_MS = 4000;

// New behavior knobs
const SYNC_EVERY_MS = 60000;          // check server time every 1 minute
const FAIL_RETRY_THRESHOLD = 3;       // pause after 3 consecutive failures

// Mask tuning
const MOSAIC_BLOCK_PX = 26;

let renderTimer = null;
let syncTimer = null;

function setStatus(msg) { statusEl.textContent = msg; }

function setLockPill(text, kind) {
  lockStateEl.textContent = text;
  lockStateEl.className = "pill " + (kind === "danger" ? "danger" : kind === "ok" ? "ok" : "mutedpill");
}
function setTimePill(text, kind) {
  timeStateEl.textContent = text;
  timeStateEl.className = "pill " + (kind === "warn" ? "warn" : "mutedpill");
}

function formatDuration(ms) {
  if (ms < 0) ms = 0;
  const totalSec = Math.floor(ms / 1000);
  const hh = String(Math.floor(totalSec / 3600)).padStart(2, "0");
  const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, "0");
  const ss = String(totalSec % 60).padStart(2, "0");
  return `${hh}:${mm}:${ss}`;
}

function populateTimeDropdowns() {
  for (let h = 0; h <= 23; h++) {
    const opt = document.createElement("option");
    opt.value = String(h);
    opt.textContent = String(h);
    hoursSel.appendChild(opt);
  }
  for (let m = 0; m <= 59; m++) {
    const opt = document.createElement("option");
    opt.value = String(m);
    opt.textContent = String(m).padStart(2, "0");
    minsSel.appendChild(opt);
  }
}

function setDelayFromMinutes(totalMinutes) {
  const h = Math.floor(totalMinutes / 60);
  const m = totalMinutes % 60;
  hoursSel.value = String(h);
  minsSel.value = String(m);
  updatePresetHighlight();
}

function updatePresetHighlight() {
  const totalMinutes = Number(hoursSel.value) * 60 + Number(minsSel.value);
  presetButtons.forEach(btn => {
    const presetMin = Number(btn.getAttribute("data-preset-min"));
    btn.classList.toggle("preset-active", presetMin === totalMinutes);
  });
}

function buildDelayMs() {
  const h = Number(hoursSel.value);
  const m = Number(minsSel.value);
  return (h * 60 + m) * 60 * 1000;
}

async function getStored() {
  return {
    photoDataUrl: await idbGet("photoDataUrl"),
    maskedPhotoDataUrl: await idbGet("maskedPhotoDataUrl"),
    localUnlockAt: await idbGet("localUnlockAt"),
    serverUnlockAt: await idbGet("serverUnlockAt"),
    createdAtLocal: await idbGet("createdAtLocal"),
    createdAtServer: await idbGet("createdAtServer")
  };
}

// ---- Mosaic mask ----

function loadImageFromDataUrl(dataUrl) {
  return new Promise((resolve, reject) => {
    const im = new Image();
    im.onload = () => resolve(im);
    im.onerror = reject;
    im.src = dataUrl;
  });
}

async function createMosaicPreviewDataUrl(fullDataUrl) {
  const im = await loadImageFromDataUrl(fullDataUrl);
  const w = im.naturalWidth || im.width;
  const h = im.naturalHeight || im.height;

  const scaleW = Math.max(1, Math.floor(w / MOSAIC_BLOCK_PX));
  const scaleH = Math.max(1, Math.floor(h / MOSAIC_BLOCK_PX));

  const small = document.createElement("canvas");
  small.width = scaleW;
  small.height = scaleH;

  const smallCtx = small.getContext("2d");
  smallCtx.imageSmoothingEnabled = true;
  smallCtx.drawImage(im, 0, 0, scaleW, scaleH);

  const out = document.createElement("canvas");
  out.width = w;
  out.height = h;

  const outCtx = out.getContext("2d");
  try { outCtx.filter = "blur(1.2px)"; } catch (_) {}
  outCtx.imageSmoothingEnabled = false;
  outCtx.drawImage(small, 0, 0, scaleW, scaleH, 0, 0, w, h);
  try { outCtx.filter = "none"; } catch (_) {}

  return out.toDataURL("image/jpeg", 0.80);
}

// ---- Time sync: background only ----

async function fetchWithTimeout(url, timeoutMs) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { signal: controller.signal, cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  } finally {
    clearTimeout(timer);
  }
}

function estimatedServerNowMs() {
  if (offsetMs === null) return null;
  return Date.now() + offsetMs;
}

function updateTimePill() {
  if (pauseDueToNetwork) {
    setTimePill("Time: cannot verify (3 failures) â€” paused", "warn");
    return;
  }
  if (offsetMs === null) {
    setTimePill("Time: not verified yet (local timer running)", "warn");
    return;
  }
  const ageSec = Math.round((Date.now() - lastSyncLocalMs) / 1000);
  const host = lastTimeSource ? new URL(lastTimeSource).host : "time service";
  setTimePill(`Time: last verified via ${host} (${ageSec}s ago)`, "muted");
}

async function backgroundSyncTimeOnce() {
  for (const url of TIME_URLS) {
    const t0 = Date.now();
    try {
      const data = await fetchWithTimeout(url, FETCH_TIMEOUT_MS);
      const t1 = Date.now();

      let serverNowMs = null;

      if (data && typeof data.utc_datetime === "string") {
        const parsed = Date.parse(data.utc_datetime);
        if (!Number.isNaN(parsed)) serverNowMs = parsed;
      }
      if (serverNowMs === null && data && typeof data.datetime === "string") {
        const parsed = Date.parse(data.datetime);
        if (!Number.isNaN(parsed)) serverNowMs = parsed;
      }
      if (serverNowMs === null && data && typeof data.unixtime === "number") {
        serverNowMs = data.unixtime * 1000;
      }
      if (serverNowMs === null && data && typeof data.epoch === "number") {
        serverNowMs = data.epoch * 1000;
      }
      if (serverNowMs === null) throw new Error("No usable time fields");

      const localMidMs = t0 + Math.round((t1 - t0) / 2);
      offsetMs = serverNowMs - localMidMs;
      lastSyncLocalMs = Date.now();
      lastTimeSource = url;

      consecutiveSyncFailures = 0;
      pauseDueToNetwork = false;
      frozenRemainingMs = null;

      // If we already have a local unlock target, translate it to server unlock target for stronger unlock gating
      const localUnlockAt = await idbGet("localUnlockAt");
      const createdAtLocal = await idbGet("createdAtLocal");
      if (localUnlockAt && createdAtLocal) {
        const delayMs = localUnlockAt - createdAtLocal;
        const serverNowEst = estimatedServerNowMs();
        const createdAtServer = serverNowEst - (Date.now() - createdAtLocal); // approximate mapping
        const serverUnlockAt = createdAtServer + delayMs;

        await idbSet("createdAtServer", createdAtServer);
        await idbSet("serverUnlockAt", serverUnlockAt);
      }

      updateTimePill();
      return true;
    } catch (e) {
      // try next provider
    }
  }

  consecutiveSyncFailures += 1;
  if (consecutiveSyncFailures >= FAIL_RETRY_THRESHOLD) {
    pauseDueToNetwork = true;
    // Freeze remaining time based on local countdown at the moment we decide to pause
    const localUnlockAt = await idbGet("localUnlockAt");
    if (localUnlockAt) {
      frozenRemainingMs = localUnlockAt - Date.now();
      if (frozenRemainingMs < 0) frozenRemainingMs = 0;
    }
  }
  updateTimePill();
  return false;
}

// ---- Camera helpers ----

function stopCameraIfRunning() {
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  video.style.display = "none";
  snapBtn.disabled = true;
  switchBtn.disabled = true;
}

async function refreshDeviceMap() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d => d.kind === "videoinput");
    let front = null, back = null;

    for (const cam of cams) {
      const label = (cam.label || "").toLowerCase();
      if (!front && (label.includes("front") || label.includes("user") || label.includes("facetime"))) front = cam.deviceId;
      if (!back && (label.includes("back") || label.includes("rear") || label.includes("environment"))) back = cam.deviceId;
    }
    if ((!front || !back) && cams.length >= 2) {
      back = back || cams[0].deviceId;
      front = front || cams[cams.length - 1].deviceId;
    }
    deviceMap.user = front;
    deviceMap.environment = back;
  } catch (_) {}
}

async function startCameraWithFacing(facing) {
  desiredFacing = facing;
  stopCameraIfRunning();

  const tryGetUserMedia = async (constraints) => {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    video.style.display = "block";
    snapBtn.disabled = false;
    switchBtn.disabled = false;
  };

  const deviceId = deviceMap[facing];

  try {
    if (deviceId) {
      await tryGetUserMedia({ video: { deviceId: { exact: deviceId } }, audio: false });
    } else {
      await tryGetUserMedia({ video: { facingMode: { ideal: facing } }, audio: false });
    }

    await refreshDeviceMap();
    switchBtn.textContent = `Switch Camera (${desiredFacing === "environment" ? "Back" : "Front"})`;
    setStatus(`Camera started (${desiredFacing === "environment" ? "Back" : "Front"}). Tap 'Take Photo'.`);
  } catch (e1) {
    try {
      await tryGetUserMedia({ video: { facingMode: { exact: facing } }, audio: false });
      await refreshDeviceMap();
      switchBtn.textContent = `Switch Camera (${desiredFacing === "environment" ? "Back" : "Front"})`;
      setStatus(`Camera started (${desiredFacing === "environment" ? "Back" : "Front"}). Tap 'Take Photo'.`);
    } catch (e2) {
      console.error(e1, e2);
      setStatus("Camera unavailable or permission denied. Ensure HTTPS + Safari and Camera permission is allowed.");
      stopCameraIfRunning();
    }
  }
}

async function startCamera() {
  // Per your request: DO NOT do server time check here
  updateTimePill();
  await startCameraWithFacing(desiredFacing);
}

async function switchCamera() {
  const next = (desiredFacing === "environment") ? "user" : "environment";
  await startCameraWithFacing(next);
}

// ---- Render ----

async function render() {
  const { photoDataUrl, maskedPhotoDataUrl, localUnlockAt, serverUnlockAt, createdAtLocal, createdAtServer } = await getStored();

  updateTimePill();

  if (!localUnlockAt || !photoDataUrl) {
    img.style.display = "none";
    img.classList.remove("maskedPreview");
    countdownEl.textContent = "--:--:--";
    setLockPill("No photo stored", "muted");
    setStatus("Ready. Start camera and take a photo. Timer starts immediately using local clock.");
    return;
  }

  // Determine remaining time
  let msLeft = localUnlockAt - Date.now();

  if (pauseDueToNetwork) {
    setLockPill("Locked (Paused)", "danger");
    if (maskedPhotoDataUrl) {
      img.src = maskedPhotoDataUrl;
      img.style.display = "block";
      img.classList.add("maskedPreview");
    } else {
      img.style.display = "none";
      img.classList.remove("maskedPreview");
    }

    if (frozenRemainingMs === null) {
      frozenRemainingMs = msLeft;
      if (frozenRemainingMs < 0) frozenRemainingMs = 0;
    }
    countdownEl.textContent = formatDuration(frozenRemainingMs);

    setStatus("Paused after 3 consecutive server time check failures. Reconnect to resume verification.");
    return;
  }

  // Not paused: countdown continues even if server time not available
  countdownEl.textContent = formatDuration(msLeft);
  if (msLeft > 0) {
    setLockPill("Locked", "danger");

    // Always show masked preview during lock
    if (maskedPhotoDataUrl) {
      img.src = maskedPhotoDataUrl;
      img.style.display = "block";
      img.classList.add("maskedPreview");
    } else {
      img.style.display = "none";
      img.classList.remove("maskedPreview");
    }

    // If we have server unlock target and server time estimate, we can show a more accurate status text
    if (serverUnlockAt && offsetMs !== null) {
      const serverNow = estimatedServerNowMs();
      const serverLeft = serverUnlockAt - serverNow;
      const unlockStr = new Date(serverUnlockAt).toLocaleString();
      setStatus(`Locked. Masked preview shown. Server-validated unlock target: ${unlockStr}. (Server remaining: ${formatDuration(serverLeft)})`);
    } else {
      const unlockStrLocal = new Date(localUnlockAt).toLocaleString();
      setStatus(`Locked. Masked preview shown. Local unlock target: ${unlockStrLocal}. (Server verification runs every 1 min.)`);
    }
  } else {
    // Local time elapsed. Only show the real photo if server verification says it's okay OR we haven't verified yet?
    // Your earlier model: server verification matters. This implementation:
    // - If we have serverUnlockAt + server time => require server elapsed.
    // - If we haven't verified yet => allow unlock by local timer (prototype convenience).
    if (serverUnlockAt && offsetMs !== null) {
      const serverNow = estimatedServerNowMs();
      if (serverNow < serverUnlockAt) {
        // Local says done, server says not yet: keep locked (show masked), show message.
        setLockPill("Locked", "danger");
        if (maskedPhotoDataUrl) {
          img.src = maskedPhotoDataUrl;
          img.style.display = "block";
          img.classList.add("maskedPreview");
        } else {
          img.style.display = "none";
          img.classList.remove("maskedPreview");
        }
        countdownEl.textContent = "00:00:00";
        setStatus("Local timer elapsed, but server time has not yet reached unlock. Waiting for server verification.");
        return;
      }
    }

    // Unlocked
    setLockPill("Unlocked", "ok");
    countdownEl.textContent = "00:00:00";
    img.src = photoDataUrl;
    img.style.display = "block";
    img.classList.remove("maskedPreview");

    const unlockStr = serverUnlockAt ? new Date(serverUnlockAt).toLocaleString() : new Date(localUnlockAt).toLocaleString();
    setStatus(`Unlocked. (Target: ${unlockStr})`);
  }
}

// ---- Actions ----

async function takePhoto() {
  if (!stream) return;

  const delayMs = buildDelayMs();
  if (delayMs <= 0) {
    setStatus("Delay must be at least 1 minute (or set a non-zero value).");
    return;
  }

  const nowLocal = Date.now();
  const localUnlockAt = nowLocal + delayMs;

  // Capture frame
  const w = video.videoWidth || 1280;
  const h = video.videoHeight || 720;
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, w, h);

  const fullDataUrl = canvas.toDataURL("image/jpeg", 0.92);

  let maskedDataUrl = null;
  try {
    maskedDataUrl = await createMosaicPreviewDataUrl(fullDataUrl);
  } catch (_) {
    maskedDataUrl = null;
  }

  // Store local schedule immediately
  await idbSet("photoDataUrl", fullDataUrl);
  await idbSet("maskedPhotoDataUrl", maskedDataUrl);
  await idbSet("createdAtLocal", nowLocal);
  await idbSet("localUnlockAt", localUnlockAt);

  // Reset server-verified values; background sync will fill them later
  await idbSet("createdAtServer", null);
  await idbSet("serverUnlockAt", null);

  // Reset pause/failure state
  consecutiveSyncFailures = 0;
  pauseDueToNetwork = false;
  frozenRemainingMs = null;

  stopCameraIfRunning();

  // Kick an immediate background sync attempt (non-blocking UI: do not await)
  backgroundSyncTimeOnce().finally(() => { /* no-op */ });

  await render();
}

async function clearAll() {
  await idbDel("photoDataUrl");
  await idbDel("maskedPhotoDataUrl");
  await idbDel("localUnlockAt");
  await idbDel("serverUnlockAt");
  await idbDel("createdAtLocal");
  await idbDel("createdAtServer");

  stopCameraIfRunning();

  offsetMs = null;
  lastSyncLocalMs = 0;
  lastTimeSource = "";
  consecutiveSyncFailures = 0;
  pauseDueToNetwork = false;
  frozenRemainingMs = null;

  await render();
}

// ---- Wiring ----

presetButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    const presetMin = Number(btn.getAttribute("data-preset-min"));
    setDelayFromMinutes(presetMin);
    setStatus(`Delay set: ${presetMin} minute(s).`);
  });
});
hoursSel.addEventListener("change", updatePresetHighlight);
minsSel.addEventListener("change", updatePresetHighlight);

startBtn.addEventListener("click", startCamera);
switchBtn.addEventListener("click", switchCamera);
snapBtn.addEventListener("click", takePhoto);
$("clear").addEventListener("click", clearAll);

// ---- Boot ----

(async () => {
  populateTimeDropdowns();
  setDelayFromMinutes(60);

  // UI refresh loop
  if (renderTimer) clearInterval(renderTimer);
  renderTimer = setInterval(render, 1000);
  await render();

  // Background sync every 1 minute (best-effort). Does NOT block camera use.
  if (syncTimer) clearInterval(syncTimer);
  syncTimer = setInterval(() => {
    backgroundSyncTimeOnce().finally(() => { /* no-op */ });
  }, SYNC_EVERY_MS);

  // On resume, attempt a background sync (non-blocking)
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
      backgroundSyncTimeOnce().finally(() => { /* no-op */ });
    }
  });

  switchBtn.disabled = true;
})();
</script>
</body>
</html>
