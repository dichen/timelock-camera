<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Time-Locked Camera</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    video, img { width: 100%; max-width: 520px; border-radius: 12px; background: #eee; }
    button, select {
      padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff;
      margin: 6px 6px 6px 0; font-size: 16px;
    }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .muted { color: #666; }
    .card { border: 1px solid #e5e5e5; border-radius: 12px; padding: 12px; margin-top: 12px; max-width: 540px; }
    .big { font-size: 18px; font-weight: 600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; border: 1px solid #ddd; }
    .danger { border-color: #f2b8b5; background: #fff5f5; }
    .ok { border-color: #b8e6c8; background: #f5fff8; }
  </style>
</head>
<body>
  <h2>Time-Locked Camera (Prototype)</h2>
  <p class="muted">Take a photo and hide it until the unlock time. Survives reload/refresh via IndexedDB.</p>

  <div class="card">
    <div class="row">
      <label class="muted">Delay:</label>
      <select id="delay">
        <option value="3600000" selected>1 hour</option>
        <option value="60000">1 minute (test)</option>
        <option value="300000">5 minutes</option>
        <option value="900000">15 minutes</option>
      </select>

      <button id="start">Start Camera</button>
      <button id="snap" disabled>Take Photo</button>
      <button id="clear">Clear Stored Photo</button>
    </div>

    <div class="row" style="margin-top:8px;">
      <span id="lockState" class="pill muted">No photo stored</span>
      <span id="countdown" class="pill muted mono">--:--:--</span>
    </div>

    <p id="status" class="muted" style="margin-top:10px;"></p>

    <video id="video" playsinline autoplay muted style="display:none; margin-top:10px;"></video>
    <canvas id="canvas" style="display:none;"></canvas>
    <img id="photo" alt="Unlocked Photo" style="display:none; margin-top: 10px;" />
  </div>

<script>
/**
 * Storage model (IndexedDB):
 * - "photoDataUrl": string (base64 data URL jpeg)
 * - "unlockAt": number (epoch ms)
 * - "createdAt": number (epoch ms)
 *
 * This persists across refresh/reload and PWA relaunch, assuming the browser does not clear site data.
 */

const dbName = "time_lock_db_v1";
const storeName = "kv";

// Basic IndexedDB KV helpers
function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(dbName, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      db.createObjectStore(storeName);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbSet(key, val) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).put(val, key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function idbGet(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const req = tx.objectStore(storeName).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbDel(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    tx.objectStore(storeName).delete(key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

// UI elements
const $ = (id) => document.getElementById(id);
const video = $("video");
const canvas = $("canvas");
const img = $("photo");
const statusEl = $("status");
const lockStateEl = $("lockState");
const countdownEl = $("countdown");
const snapBtn = $("snap");
const startBtn = $("start");

let stream = null;
let tickTimer = null;

function setStatus(msg) { statusEl.textContent = msg; }

function formatDuration(ms) {
  if (ms < 0) ms = 0;
  const totalSec = Math.floor(ms / 1000);
  const hh = String(Math.floor(totalSec / 3600)).padStart(2, "0");
  const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, "0");
  const ss = String(totalSec % 60).padStart(2, "0");
  return `${hh}:${mm}:${ss}`;
}

async function getStored() {
  const unlockAt = await idbGet("unlockAt");
  const photoDataUrl = await idbGet("photoDataUrl");
  const createdAt = await idbGet("createdAt");
  return { unlockAt, photoDataUrl, createdAt };
}

function setLockPill(state, kind) {
  lockStateEl.textContent = state;
  lockStateEl.className = "pill " + (kind === "danger" ? "danger" : kind === "ok" ? "ok" : "muted");
}

// Render (called every second to update countdown)
async function render() {
  const { unlockAt, photoDataUrl, createdAt } = await getStored();

  // No stored photo
  if (!unlockAt || !photoDataUrl) {
    img.style.display = "none";
    countdownEl.textContent = "--:--:--";
    setLockPill("No photo stored", "muted");
    setStatus("Take a photo to start the lock. Refreshing the page will not lose it.");
    return;
  }

  const now = Date.now();
  const msLeft = unlockAt - now;

  if (msLeft > 0) {
    // Locked
    img.style.display = "none";
    countdownEl.textContent = formatDuration(msLeft);
    setLockPill("Locked", "danger");
    const unlockStr = new Date(unlockAt).toLocaleString();
    const createdStr = createdAt ? new Date(createdAt).toLocaleString() : "â€”";
    setStatus(`Photo is locked. Created: ${createdStr}. Unlocks at: ${unlockStr}. (Reload/refresh is safe.)`);
  } else {
    // Unlocked
    img.src = photoDataUrl;
    img.style.display = "block";
    countdownEl.textContent = "00:00:00";
    setLockPill("Unlocked", "ok");
    const unlockStr = new Date(unlockAt).toLocaleString();
    setStatus(`Unlocked. Unlock time was: ${unlockStr}.`);
  }
}

async function startCamera() {
  try {
    // Use environment camera by default
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" },
      audio: false
    });

    video.srcObject = stream;
    video.style.display = "block";
    snapBtn.disabled = false;
    setStatus("Camera started. Tap 'Take Photo'.");
  } catch (e) {
    console.error(e);
    setStatus("Camera permission denied or unavailable. On iPhone: open via HTTPS in Safari (GitHub Pages works).");
  }
}

function stopCameraIfRunning() {
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  video.style.display = "none";
  snapBtn.disabled = true;
}

async function takePhoto() {
  if (!stream) return;

  // Capture current video frame
  const w = video.videoWidth || 1280;
  const h = video.videoHeight || 720;
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, w, h);

  // Store as JPEG data URL (prototype convenience)
  const dataUrl = canvas.toDataURL("image/jpeg", 0.92);

  const delayMs = Number($("delay").value);
  const now = Date.now();
  const unlockAt = now + delayMs;

  await idbSet("photoDataUrl", dataUrl);
  await idbSet("unlockAt", unlockAt);
  await idbSet("createdAt", now);

  stopCameraIfRunning();
  await render();
}

async function clearAll() {
  await idbDel("photoDataUrl");
  await idbDel("unlockAt");
  await idbDel("createdAt");
  stopCameraIfRunning();
  await render();
}

// Wire up buttons
$("start").addEventListener("click", startCamera);
$("snap").addEventListener("click", takePhoto);
$("clear").addEventListener("click", clearAll);

// Ensure we render immediately on load and keep countdown accurate
(async () => {
  await render();
  if (tickTimer) clearInterval(tickTimer);
  tickTimer = setInterval(render, 1000); // live countdown every second
})();

// When page becomes visible again (after app switching), re-render immediately
document.addEventListener("visibilitychange", () => {
  if (!document.hidden) render();
});
</script>
</body>
</html>

